
<html>
<head>
<style type="text/css"> 
.src { 
 font-family: monospace; 
 font-size: 90%; 
 white-space:pre;
 margin-top: 10px;
 margin-bottom: 10px;
 background-color: #ddf;
 padding: 5px;
 border: thin solid navy;
 display:none;
}
 
.button {
 color: navy;
 border: thin solid red;
}

#code {
  position: absolute;
 right:10px;
 width: 55%;
}

#summary {
 position:absolute;
 left:0;
 width: 40%;
  margin: 20 20 20 20;
 height: 100%;
}

#src_main_scala_oqube_lags_Lags_scala_3 { display: block;}
#src_test_scala_oqube_lags_LagsTest_scala_1 { display: block;}

</style>
<script language="JavaScript">
function hideShow( showId, hideId )
{
  var toshow, tohide;
  if( document.getElementById ) {// this is the way the standards work
    toShow = document.getElementById( showId );
    toHide = document.getElementById( hideId );
  } 
  else if( document.all ) {// this is the way old msie versions work
      toShow = document.all[showId];
      toHide = document.all[hideId];
  } 
  toShow.style.display = 'block';
  toHide.style.display = 'none';
}
</script>
</head>
<body>
<div id="summary">
<h1>Less naive solution with scalacheck</h1>
<p>The simpler solution can be expressed as an algorithm which  closely matches the mathematical definition of the problem: the maximal turnover from the set of acceptable sublists of a list of ordered schedules. This algorithm is rather inefficient, as it first needs to compute all sublists which is exponential in the size of the input list (note that the Haskell solution does not seem to suffer from this drawback as laziness permits some potential sublists to remain unevaluated <strong>is this true ?</strong>). but it works and it is easy to produce through TDD a robusts solution following this path.
</p>
<p>
This version builds on this foundation to produce a hopefully more efficient solution that constructs incrementally the right sublists parsing the input requests list rather than blindly compute <em>all</em> sublists. The solution it produces is then checked using <a href="http://code.google.com/p/scalacheck">Scalacheck</a>, a framework for test cases generation. The buildup of the solution follows the following sequence:
</p>
<ol>
<li>first construct a <strong>Schedule</strong> class that will hold an <em>acceptable</em> schedule, ie. an ordered sequence of requests where each pair is compatible with its follower,</li>
<li><p>we then develop a method for adding a new element to the schedule, called <code>&lt;+&gt;</code>. Building this method following TDD has some subtle traps and the generalization may seem complex, until we observe that we work under the assumption that new elements are always inserted in <em>order</em>: The new element is always greater than or eaqual (in the sense of <strong>Request</strong> class comparison) to the <em>last</em> element of the schedule, so recursion is not necessary. To simplify the code, we are lead to store the list of requests in reverse order.</p></li>
<li>This method returns a couple <strong>(Schedule, Option[Schedule])</strong> so if the new element is not compatible with the last scheduled element, we produce a new Schedule containing this element, plus all previously compatible ones. We add an <em>implicit</em> method that extracts a Schedule from this couple so that <em>chaining</em> the operator still works. By convention, we extract the newly created schedule only if it exists, else we extract the old schedule.
</li>
<li>The <strong>makeSchedules</strong> factory method is incrementally built-up through TDD, with recursion appearing nicely through refactoring of the various branches of pattern-matching. We introduce a nested function so that working on reversed input list works smoothly.
</li>
<li>
Last step is reintroduction of the <em>naive</em> solution as an <em>oracle</em> for the more complex incremental solution.
</li>
</ol>
<p>
This method is still less optimal than the first proposed solution (see <a href="http://xp-france.net/cgi-bin/wiki.pl?DojoDeveloppement">Dojo de Paris</a>) in Haskell which first built a <em>graph</em> of the <strong>&gt;&gt;&gt;</strong> relation over the input list and then produced the best solution through exploration of this graph. In the worst case, it may be exponential in the size of the input list as it may produces redundant intermediate lists. 
</p>
</div>
<div id="code">

<div id="src_main_scala_oqube_lags_Lags_scala_167" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r167) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_166','src_main_scala_oqube_lags_Lags_scala_167');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_3','src_main_scala_oqube_lags_Lags_scala_167');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  import naive.max

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = {
    def innerMake(revs : List[Request]) : List[Schedule] = {
      revs match {
	case Nil      =&gt; Nil
	case x :: Nil =&gt; List(new Schedule &lt;+&gt; x)
	case x :: xs  =&gt; innerMake(xs).flatMap(s =&gt; s &lt;+&gt; x match {
	  case (s, None)      =&gt; List(s)
	  case (s1, Some(s2)) =&gt; List(s1,s2)
	})
      }
    }
    innerMake(l.reverse)
  }
   
  def maximalTurnover(l : List[Request]) : Int = makeSchedules(l).map(_.turnover).foldLeft(0)(max)

  class Schedule {
    
    // stored in reverse insertion order
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs.reverse

    def turnover = reqs.foldLeft(0)(_ + _.price)

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      this.reqs = reqs match {
	  case Nil                    =&gt; req :: reqs
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; req :: reqs
	  case x :: xs                =&gt; nlist = req :: xs; reqs
	}
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
    }
  }      
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_166" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r166) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_165','src_main_scala_oqube_lags_Lags_scala_166');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_167','src_main_scala_oqube_lags_Lags_scala_166');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  import naive.max

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = {
    def innerMake(revs : List[Request]) : List[Schedule] = {
      revs match {
	case Nil      =&gt; Nil
	case x :: Nil =&gt; List(new Schedule &lt;+&gt; x)
	case x :: xs  =&gt; innerMake(xs).flatMap(s =&gt; s &lt;+&gt; x match {
	  case (s, None)      =&gt; List(s)
	  case (s1, Some(s2)) =&gt; List(s1,s2)
	})
      }
    }
    innerMake(l.reverse)
  }
   
  def maximalTurnover(l : List[Request]) : Int = makeSchedules(l).map(_.turnover).foldLeft(0)(max)

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def turnover = reqs.foldLeft(0)(_ + _.price)

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_165" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r165) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_164','src_main_scala_oqube_lags_Lags_scala_165');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_166','src_main_scala_oqube_lags_Lags_scala_165');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = {
    def innerMake(revs : List[Request]) : List[Schedule] = {
      revs match {
	case Nil      =&gt; Nil
	case x :: Nil =&gt; List(new Schedule &lt;+&gt; x)
	case x :: xs  =&gt; innerMake(xs).flatMap(s =&gt; s &lt;+&gt; x match {
	  case (s, None)      =&gt; List(s)
	  case (s1, Some(s2)) =&gt; List(s1,s2)
	})
      }
    }
    innerMake(l.reverse)
 }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_164" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r164) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_163','src_main_scala_oqube_lags_Lags_scala_164');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_165','src_main_scala_oqube_lags_Lags_scala_164');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = {
    def innerMake(revs : List[Request]) : List[Schedule] = {
      revs match {
	case Nil      =&gt; Nil
	case x :: Nil =&gt; List(new Schedule &lt;+&gt; x)
	case x :: xs  =&gt; innerMake(xs).flatMap(s =&gt; s &lt;+&gt; x match {
	  case (s, None)      =&gt; List(s)
	  case (s1, Some(s2)) =&gt; List(s1,s2)
	})
      }
    }
    innerMake(l.reverse)
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_163" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r163) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_162','src_main_scala_oqube_lags_Lags_scala_163');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_164','src_main_scala_oqube_lags_Lags_scala_163');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = {
    def innerMake(revs : List[Request]) : List[Schedule] = {
      revs match {
	case Nil      =&gt; Nil
	case x :: Nil =&gt; List(new Schedule &lt;+&gt; x)
	case x :: xs  =&gt; makeSchedules(xs).flatMap(s =&gt; s &lt;+&gt; x match {
	  case (s, None)      =&gt; List(s)
	  case (s1, Some(s2)) =&gt; List(s1,s2)
	})
      }
    }
    innerMake(l.reverse)
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_162" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r162) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_160','src_main_scala_oqube_lags_Lags_scala_162');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_163','src_main_scala_oqube_lags_Lags_scala_162');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = {
    def innerMake(revs : List[Request]) : List[Schedule] = {
      revs match {
	case Nil           =&gt; Nil
	case x :: Nil      =&gt; List(new Schedule &lt;+&gt; x)
	case x :: y :: Nil =&gt; makeSchedules(List(y)).flatMap(s =&gt; s &lt;+&gt; x match {
	  case (s, None)      =&gt; List(s)
	  case (s1, Some(s2)) =&gt; List(s1,s2)
	})
      }
    }
    innerMake(l.reverse)
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_160" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r160) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_159','src_main_scala_oqube_lags_Lags_scala_160');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_162','src_main_scala_oqube_lags_Lags_scala_160');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = l.reverse match {
    case Nil       =&gt; Nil
    case x :: Nil  =&gt; List(new Schedule &lt;+&gt; x)
    case x :: xs   =&gt; makeSchedules(xs).flatMap(s =&gt; s &lt;+&gt; x match {
      case (s, None)      =&gt; List(s)
      case (s1, Some(s2)) =&gt; List(s1,s2)
    })
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_159" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r159) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_158','src_main_scala_oqube_lags_Lags_scala_159');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_160','src_main_scala_oqube_lags_Lags_scala_159');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = l.reverse match {
    case Nil           =&gt; Nil
    case x :: Nil      =&gt; List(new Schedule &lt;+&gt; x)
    case x :: y :: Nil =&gt; makeSchedules(List(y)).flatMap(s =&gt; s &lt;+&gt; x match {
      case (s, None)      =&gt; List(s)
      case (s1, Some(s2)) =&gt; List(s1,s2)
    })
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_158" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r158) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_157','src_main_scala_oqube_lags_Lags_scala_158');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_159','src_main_scala_oqube_lags_Lags_scala_158');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = l match {
    case Nil           =&gt; Nil
    case x :: Nil      =&gt; List(new Schedule &lt;+&gt; x)
    case x :: y :: Nil =&gt; makeSchedules(List(x)).flatMap(s =&gt; s &lt;+&gt; y match {
      case (s, None)      =&gt; List(s)
      case (s1, Some(s2)) =&gt; List(s1,s2)
    })
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_157" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r157) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_156','src_main_scala_oqube_lags_Lags_scala_157');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_158','src_main_scala_oqube_lags_Lags_scala_157');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = l match {
    case Nil           =&gt; Nil
    case x :: Nil      =&gt; List(new Schedule &lt;+&gt; x)
    case x :: y :: Nil =&gt; new Schedule &lt;+&gt; x &lt;+&gt; y match {
      case (s, None)      =&gt; List(s)
      case (s1, Some(s2)) =&gt; List(s1,s2)
    }
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_156" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r156) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_154','src_main_scala_oqube_lags_Lags_scala_156');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_157','src_main_scala_oqube_lags_Lags_scala_156');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = l match {
    case Nil                          =&gt; Nil
    case x :: Nil                     =&gt; List(new Schedule &lt;+&gt; x)
    case x :: y :: Nil if(!(x &gt;&gt;&gt; y)) =&gt; List(new Schedule &lt;+&gt; x, new Schedule &lt;+&gt; y)
    case x :: y :: Nil                =&gt; List(new Schedule &lt;+&gt; x &lt;+&gt; y)
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_154" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r154) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_152','src_main_scala_oqube_lags_Lags_scala_154');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_156','src_main_scala_oqube_lags_Lags_scala_154');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }

  implicit def schedToIterable(s : Schedule) : List[Request] = s.schedule

  def makeSchedules( l : List[Request]) : List[Schedule] = l match {
    case Nil                          =&gt; Nil
    case x :: Nil                     =&gt; List(new Schedule &lt;+&gt; x)
    case x :: y :: Nil if(!(x &gt;&gt;&gt; y)) =&gt; List(new Schedule &lt;+&gt; x, new Schedule &lt;+&gt; y)
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_152" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r152) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_150','src_main_scala_oqube_lags_Lags_scala_152');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_154','src_main_scala_oqube_lags_Lags_scala_152');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }
  
  def makeSchedules( l : List[Request]) : List[Schedule] = l match {
    case Nil      =&gt; Nil
    case x :: Nil =&gt; List(new Schedule &lt;+&gt; x)
  }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_150" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r150) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_148','src_main_scala_oqube_lags_Lags_scala_150');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_152','src_main_scala_oqube_lags_Lags_scala_150');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }
  
  def makeSchedules( l : List[Request]) : List[Schedule] = Nil

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqsSchedule = new Schedu

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_148" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r148) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_147','src_main_scala_oqube_lags_Lags_scala_148');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_150','src_main_scala_oqube_lags_Lags_scala_148');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }
  
  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (head : List[Request], tail : List[Request]) : List[Request] = {
	tail match {
	  case Nil                    =&gt; (req :: head).reverse
	  case x :: xs  if(x &gt;&gt;&gt; req) =&gt; appendReq(x :: head, xs)
	  case x :: xs                =&gt; nlist = (req :: head).reverse; this.reqs
	}
      }
      this.reqs = appendReq(Nil, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_147" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r147) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_146','src_main_scala_oqube_lags_Lags_scala_147');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_148','src_main_scala_oqube_lags_Lags_scala_147');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }
  
  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (r : Request, list : List[Request]) : Unit = {
	list match {
	  case Nil                    =&gt; this.reqs = List(req)
	  case x :: Nil if(x &gt;&gt;&gt; req) =&gt; this.reqs = this.reqs ::: List(req)
	  case x :: Nil               =&gt; nlist = List(req)
	  case x :: xs                =&gt; appendReq(r, xs)
	}
      }
      appendReq(req, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_146" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r146) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_144','src_main_scala_oqube_lags_Lags_scala_146');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_147','src_main_scala_oqube_lags_Lags_scala_146');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
  }
  
  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      def appendReq (r : Request, list : List[Request]) : Unit = {
	list match {
	  case Nil                    =&gt; this.reqs = List(req)
	  case x :: Nil if(x &gt;&gt;&gt; req) =&gt; this.reqs = this.reqs ::: List(req)
	  case x :: Nil               =&gt; nlist = List(req)
	  case x :: xs                =&gt; appendReq(r, xs)
	}
      }
      appendReq(req, reqs)
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_144" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r144) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_142','src_main_scala_oqube_lags_Lags_scala_144');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_146','src_main_scala_oqube_lags_Lags_scala_144');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
    case (_,Some(s)) =&gt; s
  }
  
  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      this.reqs match {
	case Nil                    =&gt; this.reqs = List(req)
	case x :: Nil if(x &gt;&gt;&gt; req) =&gt; this.reqs = this.reqs ::: List(req)
	case x :: Nil               =&gt; nlist = List(req)
      }
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_142" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r142) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_140','src_main_scala_oqube_lags_Lags_scala_142');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_144','src_main_scala_oqube_lags_Lags_scala_142');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  implicit def extractSchedule(maybe : (Schedule, Option[Schedule])) : Schedule = maybe match {
    case (s,None) =&gt; s
  }
  
  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def this(ls : List[Request]) = {
      this()
      this.reqs = ls
    }

    def &lt;+&gt;(req : Request) : (Schedule,Option[Schedule]) = {
      var nlist : List[Request] = Nil
      // construct new list
      this.reqs match {
	case Nil                    =&gt; this.reqs = List(req)
	case x :: Nil if(x &gt;&gt;&gt; req) =&gt; this.reqs = this.reqs ::: List(req)
	case x :: Nil               =&gt; nlist = List(req)
      }
      // construct schedule ?
      nlist match {
	case Nil =&gt; (this, None)
	case _   =&gt; (this, Some(new Schedule(nlist)))
      }
   }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_140" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r140) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_134','src_main_scala_oqube_lags_Lags_scala_140');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_142','src_main_scala_oqube_lags_Lags_scala_140');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def &lt;+&gt;(req : Request) : Schedule = {
      this.reqs = this.reqs ::: List(req)
      this
    }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_134" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r134) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_132','src_main_scala_oqube_lags_Lags_scala_134');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_140','src_main_scala_oqube_lags_Lags_scala_134');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  class Schedule {
    
    var reqs : List[Request] = Nil

    def schedule : List[Request] = this.reqs

    def &lt;+&gt;(req : Request) : Schedule = {
      this.reqs = List(req)
      this
    }
      
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_132" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r132) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_129','src_main_scala_oqube_lags_Lags_scala_132');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_134','src_main_scala_oqube_lags_Lags_scala_132');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

  class Schedule {
    
    def schedule : List[Request] = Nil
  }
}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_129" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r129) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_127','src_main_scala_oqube_lags_Lags_scala_129');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_132','src_main_scala_oqube_lags_Lags_scala_129');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object naive {

  import request._

  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
}

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_127" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r127) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_126','src_main_scala_oqube_lags_Lags_scala_127');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_129','src_main_scala_oqube_lags_Lags_scala_127');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def turnover(list : List[Request]) : Int = list.foldLeft(0)(_ + _.price)

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(turnover)
      .foldLeft(0)(max)
  
  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_126" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r126) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_125','src_main_scala_oqube_lags_Lags_scala_126');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_127','src_main_scala_oqube_lags_Lags_scala_126');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def max(a :Int, b: Int) : Int = if(a &gt; b) a else b

  def bestTurnover(list : List[Request]) : Int = 
    sublists(list)
      .filter(isAcceptable _)
      .map(_.foldLeft(0)(_ + _.price))
      .foldLeft(0)(max)
  
  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_125" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r125) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_123','src_main_scala_oqube_lags_Lags_scala_125');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_126','src_main_scala_oqube_lags_Lags_scala_125');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def bestTurnover(list : List[Request]) : Int = list match {
    case Nil      =&gt; 0
    case x :: xs  =&gt; x.price + bestTurnover(xs)
  }

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_123" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r123) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_122','src_main_scala_oqube_lags_Lags_scala_123');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_125','src_main_scala_oqube_lags_Lags_scala_123');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) && isAcceptable(xs)
  }

  def bestTurnover(list : List[Request]) : Int = 0

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_122" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r122) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_120','src_main_scala_oqube_lags_Lags_scala_122');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_123','src_main_scala_oqube_lags_Lags_scala_122');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r)) 
		    && isAcceptable(xs)
  }

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_120" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r120) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_117','src_main_scala_oqube_lags_Lags_scala_120');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_122','src_main_scala_oqube_lags_Lags_scala_120');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil     =&gt; true
    case x :: xs =&gt; xs.foldLeft(true)((a,r) =&gt; a && (x &gt;&gt;&gt; r))
  }

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_117" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r117) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_115','src_main_scala_oqube_lags_Lags_scala_117');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_120','src_main_scala_oqube_lags_Lags_scala_117');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = list match {
    case Nil  =&gt; true
    case _    =&gt; false
  }

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_115" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r115) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_114','src_main_scala_oqube_lags_Lags_scala_115');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_117','src_main_scala_oqube_lags_Lags_scala_115');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  def isAcceptable(list : List[Request]) : Boolean = true

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_114" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r114) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_112','src_main_scala_oqube_lags_Lags_scala_114');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_115','src_main_scala_oqube_lags_Lags_scala_114');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/**
* Companion object.
*/
object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil      =&gt; List(Nil)
    case x :: xs  =&gt; {
      val sub = sublists(xs)
      sub.map(x :: _) ::: sub
    }
  }

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_112" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r112) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_111','src_main_scala_oqube_lags_Lags_scala_112');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_114','src_main_scala_oqube_lags_Lags_scala_112');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/**
* Companion object.
*/
object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil           =&gt; List(Nil)
    case x :: Nil      =&gt; List(List(x), Nil)
    case x :: y :: Nil =&gt; {
      val sub = sublists(List(y))
      sub.map(x :: _) ::: sub
    }
  }

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_111" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r111) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_109','src_main_scala_oqube_lags_Lags_scala_111');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_112','src_main_scala_oqube_lags_Lags_scala_111');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/**
* Companion object.
*/
object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = list match {
    case Nil           =&gt; List(Nil)
    case x :: Nil      =&gt; List(List(x), Nil)
    case x :: y :: Nil =&gt; List(List(x,y), List(x), 
			       List(y), Nil)
  }

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_109" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r109) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_9','src_main_scala_oqube_lags_Lags_scala_109');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_111','src_main_scala_oqube_lags_Lags_scala_109');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/**
* Companion object.
*/
object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  def sublists(list : List[Request]) : List[List[Request]] = List(Nil)

  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_9" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r9) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_7','src_main_scala_oqube_lags_Lags_scala_9');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_109','src_main_scala_oqube_lags_Lags_scala_9');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/**
* Companion object.
*/
object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt;= end
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_7" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r7) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_5','src_main_scala_oqube_lags_Lags_scala_7');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_9','src_main_scala_oqube_lags_Lags_scala_7');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/**
* Companion object.
*/
object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) {
     def &gt;&gt;&gt;(r : Request) = r.start &gt; start
   }

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_5" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r5) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_3','src_main_scala_oqube_lags_Lags_scala_5');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_7','src_main_scala_oqube_lags_Lags_scala_5');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/**
* Companion object.
*/
object request {

  /**
   * Implicit conversion for easy comparison of requests.
   */
  implicit def requestAsInt(r : Request) : Double = r.start
  
  /**
   * 
   * @author abailly@oqube.com
   * @version $Rev$
   */
   case class Request(start : Int, end : Int, price :Int) 

}

</div>
<div id="src_main_scala_oqube_lags_Lags_scala_3" class="src">
<h1>File src/main/scala/oqube/lags/Lags.scala (r3) </h1><span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_167','src_main_scala_oqube_lags_Lags_scala_3');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_main_scala_oqube_lags_Lags_scala_5','src_main_scala_oqube_lags_Lags_scala_3');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/**
 * 
 * @author abailly@oqube.com
 * @version $Rev$
 */
case class Request(start : Int, end : Int, price :Int)

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_166" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r166) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_165','src_test_scala_oqube_lags_LagsTest_scala_166');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_1','src_test_scala_oqube_lags_LagsTest_scala_166');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit4
import org.specs._
import request._
import naive._

/* use scalacheck for high-level properties */
import org.scalacheck.Prop.property
import org.scalacheck.Gen
import org.scalacheck.Prop
import Gen._
import org.scalacheck.Arbitrary
import org.scalacheck.Arb
import Arbitrary._
import org.specs.matcher.ScalacheckParameters._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  val requests = for {
    d &lt;- Gen.choose(0,23)
    f &lt;- Gen.choose(0,23) suchThat ( _ &gt; d)
    p &lt;- Gen.choose(1,100)
  } yield new Request(d,f,p)
  
  implicit def sortedRequest (g : =&gt; Gen[Request]) : Gen[List[Request]] = Gen.sized(size =&gt; for {
    n &lt;- choose(0,size)
    l &lt;- vectorOf(n,g)
  } yield l.toList.sort(_ &lt; _))
  

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(1)
      scheds(0).schedule must be_==(List(Request(1,2,3)))
    }

    "produce 2 schedules if contains 2 incompatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(2,4,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(2)
    }

    "produce 1 schedules if contains 2 compatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(5,7,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(1)
    }


    "produce 1 schedules if contains 4 compatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(5,7,3),Request(8,12,3),Request(15,20,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(1)
    }

    "allow computation of maximal turnover" in {
      
      val prop = Prop.forAll(sortedRequest(requests)) {
	ds : List[Request] =&gt; 
	  maximalTurnover(ds) == bestTurnover(ds)
      }
      prop must pass(display(minTestsOk -&gt; 50, maxDiscarded -&gt; 2000))
    }
    
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit4(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_165" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r165) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_164','src_test_scala_oqube_lags_LagsTest_scala_165');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_166','src_test_scala_oqube_lags_LagsTest_scala_165');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit4
import org.specs._
import request._
import naive._

/* use scalacheck for high-level properties */
import org.scalacheck.Prop.property
import org.scalacheck.Gen
import org.scalacheck.Prop
import Gen._
import org.scalacheck.Arbitrary
import org.scalacheck.Arb
import Arbitrary._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  val requests = for {
    d &lt;- Gen.choose(0,23)
    f &lt;- Gen.choose(0,23) suchThat ( _ &gt; d)
    p &lt;- Gen.choose(1,100)
  } yield new Request(d,f,p)
  
  implicit def sortedRequest (g : =&gt; Gen[Request]) : Gen[List[Request]] = Gen.sized(size =&gt; for {
    n &lt;- choose(0,size)
    l &lt;- vectorOf(n,g)
  } yield l.toList.sort(_ &lt; _))
  

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(1)
      scheds(0).schedule must be_==(List(Request(1,2,3)))
    }

    "produce 2 schedules if contains 2 incompatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(2,4,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(2)
    }

    "produce 1 schedules if contains 2 compatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(5,7,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(1)
    }


    "produce 1 schedules if contains 4 compatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(5,7,3),Request(8,12,3),Request(15,20,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(1)
    }

    "allow computation of maximal turnover" in {
      
      val prop = Prop.forAll(sortedRequest(requests)) {
	ds : List[Request] =&gt; 
	  maximalTurnover(ds) == bestTurnover(ds)
      }
      prop must pass 
    }
    
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit4(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_164" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r164) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_161','src_test_scala_oqube_lags_LagsTest_scala_164');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_165','src_test_scala_oqube_lags_LagsTest_scala_164');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit4
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(1)
      scheds(0).schedule must be_==(List(Request(1,2,3)))
    }

    "produce 2 schedules if contains 2 incompatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(2,4,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(2)
    }

    "produce 1 schedules if contains 2 compatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(5,7,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(1)
    }


    "produce 1 schedules if contains 4 compatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(5,7,3),Request(8,12,3),Request(15,20,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(1)
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit4(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_161" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r161) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_155','src_test_scala_oqube_lags_LagsTest_scala_161');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_164','src_test_scala_oqube_lags_LagsTest_scala_161');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit4
import org.specs._
import request._
import naive._

/* use scalacheck for high-level properties */
import org.scalacheck.Prop.property
import org.scalacheck.Gen
import org.scalacheck.Prop
import Gen._
import org.scalacheck.Arbitrary
import org.scalacheck.Arb
import Arbitrary._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  val requests = for {
    d &lt;- Gen.choose(0,23)
    f &lt;- Gen.choose(0,23) suchThat ( _ &gt; d)
    p &lt;- Gen.choose(1,100)
  } yield new Request(d,f,p)
  
  implicit def sortedRequest (g : =&gt; Gen[Request]) : Gen[List[Request]] = Gen.sized(size =&gt; for {
    n &lt;- choose(0,size)
    l &lt;- vectorOf(n,g)
  } yield l.toList.sort(_ &lt; _))
  

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(1)
      scheds(0).schedule must be_==(List(Request(1,2,3)))
    }

    "produce 2 schedules if contains 2 incompatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(2,4,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(2)
    }

    "produce 1 schedules if contains 2 compatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(5,7,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(1)
    }

    "allow computation of maximal turnover" in {
      
      val prop = Prop.forAll(sortedRequest(requests)) {
	ds : List[Request] =&gt; 
	  maximalTurnover(ds) == bestTurnover(ds)
      }
      prop must pass (display(minTestsOk -&gt; 20))
    }
    
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit4(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_155" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r155) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_154','src_test_scala_oqube_lags_LagsTest_scala_155');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_161','src_test_scala_oqube_lags_LagsTest_scala_155');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit4
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(1)
      scheds(0).schedule must be_==(List(Request(1,2,3)))
    }

    "produce 2 schedules if contains 2 incompatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(2,4,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(2)
    }

    "produce 1 schedules if contains 2 compatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(5,7,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(1)
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit4(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_154" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r154) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_153','src_test_scala_oqube_lags_LagsTest_scala_154');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_155','src_test_scala_oqube_lags_LagsTest_scala_154');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit4
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(1)
      scheds(0).schedule must be_==(List(Request(1,2,3)))
    }

    "produce 2 schedules if contains 2 incompatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(2,4,3))
      val scheds : List[Schedule] = makeSchedules(list)
      scheds.length must be(2)
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit4(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_153" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r153) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_152','src_test_scala_oqube_lags_LagsTest_scala_153');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_154','src_test_scala_oqube_lags_LagsTest_scala_153');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(1)
      scheds(0).schedule must be_==(List(Request(1,2,3)))
    }

    "produce 2 schedules if contains 2 incompatible requests" in {
      val list : List[Request] = List(Request(1,3,3),Request(2,4,3))
      val scheds = makeSchedules(list)
      scheds.length must be(2)
      scheds must haveSameElementsAs(List(List(Request(1,3,3)),List(Request(2,4,3))))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_152" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r152) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_151','src_test_scala_oqube_lags_LagsTest_scala_152');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_153','src_test_scala_oqube_lags_LagsTest_scala_152');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(1)
      scheds(0).schedule must be_==(List(Request(1,2,3)))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_151" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r151) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_149','src_test_scala_oqube_lags_LagsTest_scala_151');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_152','src_test_scala_oqube_lags_LagsTest_scala_151');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }

  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }

    "produce a single schedule if a singleton" in {
      val list : List[Request] = List(Request(1,2,3))
      val scheds = makeSchedules(list)
      scheds.length must be(0)
      scheds(0).schedule must be_==(List(Request(1,2,3))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_149" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r149) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_147','src_test_scala_oqube_lags_LagsTest_scala_149');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_151','src_test_scala_oqube_lags_LagsTest_scala_149');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }
  }

  "a list of ordered requests" should {
    
    "produce an empty schedule if empty" in {
      val list : List[Request] = Nil
      makeSchedules(list) must beEmpty
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_147" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r147) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_145','src_test_scala_oqube_lags_LagsTest_scala_147');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_149','src_test_scala_oqube_lags_LagsTest_scala_147');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
    
"store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_145" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r145) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_144','src_test_scala_oqube_lags_LagsTest_scala_145');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_147','src_test_scala_oqube_lags_LagsTest_scala_145');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }

    "store three compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      val r3 = Request(5,6,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3).schedule must be_==(List(r1,r2,r3))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_144" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r144) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_143','src_test_scala_oqube_lags_LagsTest_scala_144');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_145','src_test_scala_oqube_lags_LagsTest_scala_144');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s : Schedule = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_143" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r143) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_141','src_test_scala_oqube_lags_LagsTest_scala_143');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_144','src_test_scala_oqube_lags_LagsTest_scala_143');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added to one element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }

    "return new schedule if an incompatible request is added to 2-element list" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(3,5,2)
      val r3 = Request(4,6,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 &lt;+&gt; r3
      sched.schedule must be_==(List(r1,r2))
      s.schedule must be_==(List(r1,r3))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_141" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r141) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_139','src_test_scala_oqube_lags_LagsTest_scala_141');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_143','src_test_scala_oqube_lags_LagsTest_scala_141');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }

    "return new schedule if an incompatible request is added" in {
      val sched = new Schedule
      val r1 = Request(1,3,2)
      val r2 = Request(2,4,2)
      val s = sched &lt;+&gt; r1 &lt;+&gt; r2 
      s._2.get.schedule must be_==(List(r2))
      s._1.schedule must be_==(List(r1))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_139" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r139) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_133','src_test_scala_oqube_lags_LagsTest_scala_139');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_141','src_test_scala_oqube_lags_LagsTest_scala_139');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

    "store two compatible requests added in order" in {
      val sched = new Schedule
      val r1 = Request(1,2,2)
      val r2 = Request(3,4,2)
      (sched &lt;+&gt; r1 &lt;+&gt; r2).schedule must be_==(List(r1,r2))
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_133" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r133) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_132','src_test_scala_oqube_lags_LagsTest_scala_133');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_139','src_test_scala_oqube_lags_LagsTest_scala_133');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }

    "allow initial addition of a request and store it" in {
      val sched = new Schedule
      val req = Request(1,1,2)
      (sched &lt;+&gt; req).schedule must be_==(List(req))
      
    }

  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_132" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r132) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_131','src_test_scala_oqube_lags_LagsTest_scala_132');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_133','src_test_scala_oqube_lags_LagsTest_scala_132');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      (new Schedule).schedule must be_==(Nil)
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_131" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r131) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_130','src_test_scala_oqube_lags_LagsTest_scala_131');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_132','src_test_scala_oqube_lags_LagsTest_scala_131');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)

  "a lags schedule" should {

    "be constructed empty" in {
      new Schedule.schedule must be_==(Nil)
    }
  }
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_130" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r130) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_129','src_test_scala_oqube_lags_LagsTest_scala_130');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_131','src_test_scala_oqube_lags_LagsTest_scala_130');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

object LagsObjectSpecification extends Specification {

  "a more efficient scheduling algorithm".isSpecifiedBy(LagsSpecification)
}
  


/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsObjectSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_129" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r129) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_124','src_test_scala_oqube_lags_LagsTest_scala_129');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_130','src_test_scala_oqube_lags_LagsTest_scala_129');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._
import naive._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_124" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r124) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_121','src_test_scala_oqube_lags_LagsTest_scala_124');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_129','src_test_scala_oqube_lags_LagsTest_scala_124');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }
    
  }

  "a maximal turnover from a list" should {
      
    "be 0 for an empty list" in {
      val list = Nil
      bestTurnover(list) must be(0)
    }

    "be its turnover for a singleton list" in {
      val req = Request(1,3,3)
      val list = List(req)
      bestTurnover(list) must be(req.price)
    }

    "be the sum of price for an acceptable list with more than 1 element" in {
      val list = List(Request(1,3,3),Request(3,5,6))
      bestTurnover(list) must be(9)
    }

    
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_121" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r121) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_119','src_test_scala_oqube_lags_LagsTest_scala_121');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_124','src_test_scala_oqube_lags_LagsTest_scala_121');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements not at first place is not acceptable" in {
      val list = List(Request(1,3,3),Request(3,5,3),Request(4,5,3))
      isAcceptable(list) must be(false)
    }

    
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_119" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r119) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_118','src_test_scala_oqube_lags_LagsTest_scala_119');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_121','src_test_scala_oqube_lags_LagsTest_scala_119');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }

    "a list with 1 element is compatible" in {
      val list = List(Request(1,3,3))
      isAcceptable(list) must be(true)
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_118" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r118) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_116','src_test_scala_oqube_lags_LagsTest_scala_118');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_119','src_test_scala_oqube_lags_LagsTest_scala_118');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

    "a list with 2 incompatible elements is not acceptable" in {
      val list = List(Request(1,3,3),Request(2,4,3))
      isAcceptable(list) must be(false)
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_116" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r116) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_113','src_test_scala_oqube_lags_LagsTest_scala_116');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_118','src_test_scala_oqube_lags_LagsTest_scala_116');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }

  "checking compatible lists" should {
    
    "an empty list is acceptable" in {
      val list = Nil
      isAcceptable(list) must be(true)
    }

  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_113" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r113) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_110','src_test_scala_oqube_lags_LagsTest_scala_113');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_116','src_test_scala_oqube_lags_LagsTest_scala_113');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }

    "be a 16-element list for a 4-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4),Request(3,3,4),Request(4,5,4))
      val subs = sublists(l)
      subs.length must be(16)
      subs must contain(List(Request(1,2,3),Request(4,5,4)))
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_110" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r110) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_108','src_test_scala_oqube_lags_LagsTest_scala_110');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_113','src_test_scala_oqube_lags_LagsTest_scala_110');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }
  }

  "the sublists of a list" should {
    
    val norequest : List[Request] = Nil

    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(norequest))
    }

    "be a 2-element list for a singleton list" in {
      val l = List(Request(1,2,3))
      val subs = sublists(l)
      subs.length must be(2)
      subs must contain(List(Request(1,2,3)))
      subs must contain(norequest)
    }

    "be a 4-element list for a 2-element list" in {
      val l = List(Request(1,2,3),Request(2,3,4))
      val subs = sublists(l)
      subs.length must be(4)
      subs must contain(List(Request(1,2,3),Request(2,3,4)))
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_108" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r108) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_10','src_test_scala_oqube_lags_LagsTest_scala_108');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_110','src_test_scala_oqube_lags_LagsTest_scala_108');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {

    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be compatible if it starts after ends of other request" in {
      val d = Request(4, 8 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(true)
    }
  }

  "the sublists of a list" should {
    
    "be the singleton nil for empty list" in {
      val l = Nil
      sublists(l) must be_==(List(Nil))
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_10" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r10) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_8','src_test_scala_oqube_lags_LagsTest_scala_10');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_108','src_test_scala_oqube_lags_LagsTest_scala_10');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {
    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it includes it" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 2 ,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is included in it" in {
      val d = Request(3, 4 ,50)
      val d2 = Request(1, 12,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be incompatible with some other request if it is overlapped" in {
      val d = Request(3, 5 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(false)
    }

    "be compatible if it starts after ends of other request" in {
      val d = Request(4, 8 ,50)
      val d2 = Request(1, 4,50)
      d &gt;&gt;&gt; d2 must be(true)
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_8" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r8) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_7','src_test_scala_oqube_lags_LagsTest_scala_8');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_10','src_test_scala_oqube_lags_LagsTest_scala_8');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {
    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }

    "be incompatible with some other request if times do overlap" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d &gt;&gt;&gt; d2 must be false
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_7" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r7) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_6','src_test_scala_oqube_lags_LagsTest_scala_7');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_8','src_test_scala_oqube_lags_LagsTest_scala_7');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {
    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be(true)
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_6" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r6) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_5','src_test_scala_oqube_lags_LagsTest_scala_6');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_7','src_test_scala_oqube_lags_LagsTest_scala_6');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {
    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }

    "be compatible with other request if times do not overlap" in {
      val d = Request(1, 4 ,50)
      val d3 = Request(4, 5 ,50)
      d &gt;&gt;&gt; d3 must be true
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_5" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r5) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_4','src_test_scala_oqube_lags_LagsTest_scala_5');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_6','src_test_scala_oqube_lags_LagsTest_scala_5');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._
import request._


/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {
    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_4" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r4) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_1','src_test_scala_oqube_lags_LagsTest_scala_4');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_5','src_test_scala_oqube_lags_LagsTest_scala_4');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._

/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {
    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }

    "be comparable by start date to some other request" in {
      val d = Request(1, 4 ,50)
      val d2 = Request(3, 4 ,50)
      d2 must beStrictlyGreaterThan(d)
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
<div id="src_test_scala_oqube_lags_LagsTest_scala_1" class="src">
<h1>File src/test/scala/oqube/lags/LagsTest.scala (r1) </h1><span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_166','src_test_scala_oqube_lags_LagsTest_scala_1');">&lt;&lt;&lt</span> <span class="button" onclick="javascript:hideShow('src_test_scala_oqube_lags_LagsTest_scala_4','src_test_scala_oqube_lags_LagsTest_scala_1');">&gt;&gt;&gt</span> 
/**
 *  Copyright (C) 2008 - OQube / Arnaud Bailly
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on Thu Jan 24 2008
 */
package oqube.lags

/*
 * needed imports for specs
 */
import junit.framework._
import org.specs.runner.JUnit3
import org.specs._

/**
 * Specification of LAGS problem.
 */
object LagsSpecification extends Specification {
  
  "a reservation request" should {
    "be defined by its start, end hour and price" in {
      val d = Request(1,4,50)
      d.start must be(1)
      d.end must be(4)
      d.price must be(50)
    }
  }
}

/**
 * Tests pour le projet LAGS.
 * @author abailly@oqube.com
 * @version $Rev$
 */
class LagsTest extends JUnit3(LagsSpecification) 

</div>
</div>
</body>
